# Sistemas Operacionais

## Introdu√ß√£o

### **O que acontece quando um programa √© executado?**

√â bastante simples: uma cadeia de instru√ß√µes s√£o executadas - nos dias de hoje, um i7 de 5.00 GHz, por exemplo, executa 221,720 MIPS ou 220 bi IPS

Podemos pensar como um fluxo cont√≠nuo onde a CPU: 

- Busca instru√ß√µes da mem√≥ria
- Decodifica as instru√ß√µes - entende qual √© a instru√ß√£o
- Executa a instru√ß√£o (opera√ß√µes matem√°ticas, acessar mem√≥ria, pular para outra instru√ß√£o, checar uma condi√ß√£o, etc..)

Claro que isso √© a parte "simples", conhecido como modelo Von Neumann de computa√ß√£o. Hoje as CPUs fazem coisas muito mais bizarras e engenhosas.

### **Virtualiza√ß√£o de CPU**

Imagina que estamos em uma sala, todos n√≥s com muita fome e tem apenas uma ma√ßa. Se cada um for comer ate se saciar teremos um problema, certo? Vai demorar muito. E se pudermos distribuir uma ma√ßa virtual onde a gente pensa que est√° comendo a ma√ßa real mas na verdade estamos dividindo ela. E para fazer isso sem que todo mundo perceba, vamos dar a ma√ßa real e rouba-l√° quando estiverem "moscando" ou fazendo qualquer outra coisa e assim por diante.

O Sistema Operacional consegue criar uma ilus√£o de v√°rias CPUs como uma t√©cnica chamada **Time Sharing**. D√°-se um pouco de tempo de processamento para cada processo. Claro que isso vem com um custo em performance pois a CPU vai ser dividida entre todos os processos.

Para que o **Time Sharing** funcione de fato, √© necess√°rio dois mecanismos: Um de **baixo n√≠vel** "mec√¢nico" (Context Switch) e um de **alto n√≠vel** "inteligente" (Pol√≠ticas de escalonamento).

## **Processos**

Do ponto de vista do Sistema Operacional, √© tudo processo. Podemos dizer que um **Processo** nada mais √© que um **Programa em execu√ß√£o**. 

Para entender o que √© um processo, precisamos entender dois pilares fundamentais:

**Mem√≥ria**: Tudo tem a ver com mem√≥ria. As instru√ß√µes est√£o na mem√≥ria, os resultados s√£o colocados na mem√≥ria, os dados de entrada est√£o na mem√≥ria e √© conhecido como **Address Space.**

**Registradores**: Uma conven√ß√£o de endere√ßos para manipular informa√ß√µes. Vale ressaltar que temos alguns bem importantes como o **PC (Program Counter ou IP Instruction Pointer - %eip)** que nos diz qual instru√ß√£o ser√° executada em sequencia; temos o **StackPointer (%esp)** e **FramePointer (%ebp)**, que ajuda a manter o controle da stack (fun√ß√µes, par√¢metros, vari√°veis locais, endere√ßo de retorno).

### **Transformando um programa em um processo**

O primeiro passo que um Sistema Operacional precisa fazer √© carregar o programa na mem√≥ria.

![carregando o programa](/assets/operating-systems-virtualization-concurrency-persistence/carregando-um-programa.png)

Com parte do programa em mem√≥ria (**lazy**), o sistema vai alocar um pouco de mem√≥ria para o que conhecemos como Stack. Em um programa em C, por exemplo, fica no Stack os apontamentos para vari√°veis locais, fun√ß√µes e endere√ßos de retorno.

Com a Stack em ordem, um pouco mais de mem√≥ria √© necess√°rio para o Heap - Que s√£o usados para estruturas din√¢micas alocadas com `malloc`.

Com Heap pronto, √© hora de encontrar o `main` , popular a Stack com `argc` e `argv` e iniciar o programa.

> `int main (int argc, char *argv[]);`
> 

- **Curiosidades sobre tarefas antes da execu√ß√£o de um processo**
    
    Existem algumas tarefas relacionadas ao I/O de um programa que o OS faz logo de inicio, durante a prepara√ß√£o acima. Por exemplo, todo processo UNIX cria-se tr√™s **file descriptors** para o processo para **standard input, output e error**.
    

> By loading the code and static data into memory, creating and initializing a stack, and doing other work as related to I/O setup, the OS has now (finally) set the stage for program execution. It thus has one last task: to start the program running at the entry point, namely main(). By jumping to the main() routine (through a specialized mechanism that we will discuss next chapter), the OS transfers control of the CPU to the newly-created process, and thus the program begins its execution.
> 

### **Os estados de um Processo**

De uma maneira simplificada, temos tr√™s estados principais: READY, RUNNING e BLOCKED.

![](/assets/operating-systems-virtualization-concurrency-persistence/estados-de-um-programa.png)

O cen√°rio ideal de um Scheduler seria:

![](/assets/operating-systems-virtualization-concurrency-persistence/transicao-feliz-de-um-programa.png)

### **O que o OS sabe sobre um processo?**

Na imagem abaixo, √© poss√≠vel ver todos as informa√ß√µes que um xv6 kernel mant√©m sobre um processo:

![](/assets/operating-systems-virtualization-concurrency-persistence/kernel-code.png)

Nessa estruturas podemos ver partes de informa√ß√£o importantes que um OS armazena sobre um processo. Dentre eles, temos o **register context** que √© o que possibilita o stop e resume de um processo pois armazena em que ponto ele parou.

Esse processo de armazenar os registradores e depois repor os valores de registradores √© o que chamamos de **Context Switch** e quem o faz √© a parte baixo n√≠vel que comentei.

### Curiosidade: Process API

As **system calls** utilizadas para manipular processos UNIX s√£o: **fork**, **exec** e **wait**.

- `fork()` faz uma c√≥pia do programa atual e continua a execu√ß√£o do ponto do fork.
- `exec()` faz a substitui√ß√£o do programa atual para um outro e, normalmente, √© utiliza p√≥s form.
- `wait()` faz esperar o resultado do file-descritor.

![](/assets/operating-systems-virtualization-concurrency-persistence/process-api.png)

Basicamente, o c√≥digo acima cria um novo processo baseado no atual, onde continua a partir do `fork` statement. Para o processo filho, o valor de `rc` √© 0 e para o pai √© o `pid` do filho. Dessa forma √© poss√≠vel saber se o c√≥digo em execu√ß√£o √© no pai ou no filho.

> Como o Scheduler do OS √© imprevis√≠vel, o comportamento do print √© n√£o determin√≠stico, ou seja, pode primeiro aparecer o log do filho, como pode ser o do processo pai.


![](/assets/operating-systems-virtualization-concurrency-persistence/spanwing-process-with-param.png)

No exemplo acima introduzimos o `exec()` e o `wait()`. Quando a vari√°vel `rc` √© igual a 0, significa que estamos no processo filho e seguro de que podemos chamar o `exec` o qual ir√° substituir o programa do processo atual inteiro pelo novo execut√°vel. Toda a Stack, Heap, Ponteiros ser√£o realocados para o novo programa mas no mesmo processo.

Voc√™ deve estar se perguntando, porqu√™ existe isso?

A resposta √© simples: Shell.
![](/assets/operating-systems-virtualization-concurrency-persistence/shell-pipes.png)

Pronto. Agora pode dizer que sabe como criar um Shell üòù

## Virtualiza√ß√£o: Limited Direct Execution

Agora que sabemos o que √© um processo, podemos voltar para o ponto onde a CPU executa o mesmo e os outros processos. Por agora, √© importante saber que por conta de performance, n√£o criamos CPUs virtuais, e sim, executamos os processos diretamente nas CPUs mas por um tempo limitado, at√© substituirmos o processo por outro: **Time Sharing**.

![](/assets/operating-systems-virtualization-concurrency-persistence/program-startup.png)

Voc√™ pode estar se perguntando: Se executamos os processos direto na CPU, como ent√£o o OS pausa o processo e substitui o mesmo se n√£o √© ele quem est√° com a bola? Al√©m disso, como um programa acessaria recursos de hardware (I/O)? Executaria as instru√ß√µes direto na CPU? E a seguran√ßa?

Por conta dessa arquitetura, √© preciso introduzir o conceito de Modos de Processos. Por padr√£o, as aplica√ß√µes s√£o iniciadas no **User Mode** e, toda vez que um I/O √© necess√°rio, √© feito um **system call** onde passasse o controle para o Kernel o qual √© executado em **Kernel Mode**. 

Essas funcionalidades chamadas de **system calls** s√£o instru√ß√µes que seguem uma norma chamada POSIX. √â um nome bem comum e todos os Sistemas Operacionais se baseiam nela.

### Trap Instructions especiais

Para executar uma **sys-call**, o programa precisa executar uma instru√ß√£o especial conhecida como **trap**. Esta instru√ß√£o faz a CPU pular para o kernel e mudar os privil√©gios para kernel mode. Uma vez dentro do kernel, o trabalho √© realizado e ent√£o uma outra instru√ß√£o especial √© executada: **return-from-trap**. Onde √© retornado a execu√ß√£o e o privil√©gio para user-mode.

### Se o processo est√° com a bola, como o Scheduler joga?

Trocar de processo em execu√ß√£o deveria ser simples, certo? O Scheduler do Sistema Operacional pausa um processo e inicia outro. Mas ai te pergunto: se o processo est√° executando na CPU e n√£o o OS, como o OS consegue poderes para tal? Esse √© um dos problemas que temos ao utilizar a abordagem de execu√ß√£o direta (Direct Execution) na CPU. 

**Uma abordagem cooperativa: System calls**

No passado, essa era a abordagem utilizada por alguns sistemas. A abordagem cooperativa √© passiva e espera que o processo devolva o controle ao OS via **system calls**. Exemplos de system calls  s√£o chamadas externa via internet, chamadas ao disco r√≠gido para ler um arquivo, criar um processo, aguardar um processo, etc. Essas chamadas incluem implicitamente o que chamamos de *yield*, onde o processo devolve controle ao OS.

O problema com essa abordagem √©: o que acontece se um processo n√£o fizer nenhum um tipo de system call? Seja por algum bug acidental onde se encontra em um loop infinito ou algo malicioso - Huston, we have a problem! REBOOT.

**Uma abordagem radical: Timer Interrupt**

Essa nova abordagem, mais radical, √© a solu√ß√£o para a pergunta da abordagem anterior. Com a ajuda do hardware, um dispositivo de timer f√≠sico, interrompe a CPU de tempos em tempos. Toda vez que o Sistema Operacional se inicializa, o mesmo configura o tempo do timer e qual a localiza√ß√£o do c√≥digo "*handler*" o qual ser√° executado quando a CPU for interrompida.

Observe que por ser uma interrup√ß√£o for√ßada, o **hardware** vai se esfor√ßar o m√°ximo para tentar armazenar todo o contexto do processo em execu√ß√£o e configurar um return-from-trap para que o mesmo seja resumido futuramente.

### Context Switch

Seja pela abordagem bruta ou pela cooperativa, uma vez que o Sistema Operacional retoma o controle ele precisa executar o Scheduler para que a decis√£o seja tomada, seja continuar executando o processo atual ou selecionar algum outro. Caso a decis√£o seja executar outro processo, inicia-se ent√£o o processo de **Context Switch**.

Para salvar o contexto do processo atual, uma s√©rie de instru√ß√µes de baixo n√≠vel √© executado para salvar os Registradores, PC (Program Counter), Kernel Stack Pointer do processo atual.

![](/assets/operating-systems-virtualization-concurrency-persistence/context-switch.png)

Exemplo de c√≥digo executado ao realizar a switch routine:

![](/assets/operating-systems-virtualization-concurrency-persistence/context-switch-code.png)